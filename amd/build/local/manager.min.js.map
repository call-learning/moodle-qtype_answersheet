{"version":3,"file":"manager.min.js","sources":["../../src/local/manager.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * TODO describe module manager\n *\n * @module     qtype_answersheet/local/manager\n * @copyright  2024 Bas Brands <bas@sonsbeekmedia.nl>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport State from 'qtype_answersheet/local/state';\nimport Repository from 'qtype_answersheet/local/repository';\nimport Notification from 'core/notification';\nimport {get_string as getString} from 'core/str';\nimport './components/table';\n\n/**\n * Manager class.\n * @class\n */\nclass Manager {\n\n    /**\n     * Row number.\n     */\n    rowNumber = 0;\n\n    /**\n     * The questionid.\n     * @type {Number}\n     */\n    questionid;\n\n    /**\n     * The temp row id.\n     * @type {Number}\n     */\n    temprowid = 1000;\n\n    /**\n     * The element.\n     * @type {HTMLElement}\n     */\n    element;\n\n    /**\n     * The table name.\n     */\n    table = 'qtype_answersheet';\n\n    /**\n     * The table columns.\n     * @type {Array}\n     */\n    columns = [];\n\n    /**\n     * Types definition\n     */\n    TYPES = {\n        '1': 'radiochecked',\n        '2': 'letterbyletter',\n        '3': 'freetext'\n    };\n\n    /**\n     * Constructor.\n     * @param {HTMLElement} element The element.\n     * @param {String} questionid The questionid.\n     * @return {void}\n     */\n    constructor(element, questionid) {\n        this.element = element;\n        this.questionid = parseInt(questionid);\n        this.addEventListeners();\n        this.getDatagrid();\n        this.tempfield = document.querySelector('input[name=\"jsonquestions\"]');\n    }\n\n    /**\n     * Add event listeners.\n     * @return {void}\n     */\n    addEventListeners() {\n        const form = document.querySelector('[data-region=\"app\"]');\n        form.addEventListener('click', (e) => {\n            let btn = e.target.closest('[data-action]');\n            if (btn) {\n                e.preventDefault();\n                this.actions(btn);\n            }\n        });\n        // Listen to all changes in the table.\n        form.addEventListener('change', (e) => {\n            const input = e.target.closest('[data-input]');\n            if (input) {\n                this.change(input);\n            }\n            const modulename = e.target.closest('[data-region=\"modulename\"]');\n            if (modulename) {\n                this.changeModule(modulename);\n            }\n            const moduletype = e.target.closest('[data-region=\"moduletype\"]');\n            if (moduletype) {\n                this.changeModule(moduletype);\n            }\n            const questionpoints = e.target.closest('[data-region=\"questionpoints\"]');\n            if (questionpoints) {\n                this.changeModule(questionpoints);\n            }\n            this.setTableData();\n        });\n        // Listen to the arrow down and up keys to navigate to the next or previous row.\n        form.addEventListener('keydown', (e) => {\n            if (e.key === 'ArrowDown' || e.key === 'ArrowUp') {\n                this.navigate(e);\n                e.preventDefault();\n            }\n            if (e.key === 'Enter') {\n                e.preventDefault();\n            }\n        });\n        form.addEventListener('submit', (e) => {\n            e.preventDefault();\n        });\n    }\n\n    async getDatagrid() {\n        await this.getTableData();\n        await this.getTableConfig();\n    }\n\n    /**\n     * Get the table configuration.\n     * @return {Promise} The promise.\n     */\n    async getTableConfig() {\n        const response = await Repository.getColumns({table: this.table});\n        await State.setValue('columns', response.columns);\n    }\n\n    /**\n     * Get the table data.\n     * @return {void}\n     */\n    async getTableData() {\n        try {\n            const response = await Repository.getData({questionid: this.questionid});\n            // Validate the response, the response.date should be a string that can be parsed to a JSON object.\n            const modules = await this.parseModules(response.modules);\n            State.setValue('modules', modules);\n            this.setTableData();\n        } catch (error) {\n            Notification.exception(error);\n        }\n    }\n\n    /**\n     * Parse the modules, add the correct column properties to each cell.\n     * @param {Array} modules The modules.\n     * @return {Array} The parsed rows.\n     */\n    async parseModules(modules) {\n        for (const mod of modules) {\n            const type = this.TYPES[mod.type];\n            mod[type] = true;\n            mod.indicator = await this.getIndicator(mod.numoptions, mod.type);\n            mod.rows.forEach((row) => {\n                let selectedValue = '';\n                row.cells.forEach(cell => {\n                    if (cell.column === 'answer') {\n                        selectedValue = cell.value;\n                    }\n                });\n                row.cells = row.cells.map(cell => {\n                    const column = mod.columns.find(column => column.column === cell.column);\n                    // Clone the column properties to the cell but keep the cell properties.\n                    cell = Object.assign({}, cell, column);\n                    if (cell.type === 'select') {\n                        // Clone the options array to avoid shared references\n                        cell.options = cell.options.map(option => {\n                            const clonedOption = Object.assign({}, option);\n                            if (clonedOption.name === selectedValue) {\n                                clonedOption.selected = true;\n                            }\n                            return clonedOption;\n                        });\n                    }\n                    cell.edit = true;\n                    return cell;\n                });\n            });\n        }\n        // To calculate the answerid index, so we can make up an id related to the row index.\n        // Used in behat tests to find the correct answer input.\n        modules = await this.recomputeIds(modules);\n        return modules;\n    }\n    /**\n     * Get the row object that can be accepted by the webservice.\n     * @return {Array} The keys.\n     */\n    getRowObject() {\n        return {\n            'rows': {\n                'id': 'id',\n                'sortorder': 'sortorder',\n                'cells': {\n                    'type': 'type',\n                    'column': 'column',\n                    'value': 'value',\n                },\n            },\n        };\n    }\n\n    /**\n     * Check the cell value. It can not exceed the cell length.\n     * @param {object} cell The cell.\n     * @return {void}\n     */\n    checkCellValue(cell) {\n        if (cell.value === null) {\n            return;\n        }\n        if (cell.type === 'text' && cell.value.length > cell.length) {\n            cell.value = cell.value.substring(0, cell.length);\n        }\n    }\n\n\n    /**\n     * Clean the Modules array.\n     * @param {Array} modules The modules.\n     * @return {Array} The cleaned modules.\n     */\n    cleanModules(modules) {\n        const cleanedModules = [];\n        modules.forEach(module => {\n            const rows = module.rows;\n            const rowObject = this.getRowObject();\n            const cleanedRows = rows.map(row => {\n                const cleanedRow = {};\n                Object.keys(rowObject.rows).forEach(key => {\n                    cleanedRow[key] = row[key];\n                });\n                // Clean the cells.\n                cleanedRow.cells = row.cells.map(cell => {\n                    const cleanedCell = {};\n                    this.checkCellValue(cell);\n                    Object.keys(rowObject.rows.cells).forEach(key => {\n                        cleanedCell[key] = cell[key];\n                        if (cell.column === 'options' && key === 'value') {\n                            cleanedCell[key] = cell['options']?.map(option => option.name);\n                        }\n                    });\n                    return cleanedCell;\n                });\n                return cleanedRow;\n            });\n            const cleanedModule = {};\n            cleanedModule.sortorder = module.modulesortorder;\n            cleanedModule.name = module.modulename;\n            cleanedModule.type = module.type;\n            cleanedModule.numoptions = module.numoptions;\n            cleanedModule.rows = cleanedRows;\n            cleanedModule.questionpoints = module.questionpoints;\n            cleanedModules.push(cleanedModule);\n        });\n        return cleanedModules;\n    }\n\n    /**\n     * Set the table data.\n     * @return {void}\n     */\n    async setTableData() {\n        const modules = State.getValue('modules');\n        const cleanedModules = this.cleanModules(modules);\n        this.tempfield.value = JSON.stringify(cleanedModules);\n    }\n\n    /**\n     * Actions.\n     * @param {object} btn The button that was clicked.\n     */\n    actions(btn) {\n        if (btn.dataset.action === 'addrow') {\n            this.addRow(btn);\n        }\n        if (btn.dataset.action === 'deleterow') {\n            this.deleteRow(btn);\n        }\n        if (btn.dataset.action === 'addmodule') {\n            this.addModule(btn);\n        }\n        if (btn.dataset.action === 'deletemodule') {\n            this.deleteModule(btn);\n        }\n        if (btn.dataset.action === 'moduleremoveoption') {\n            this.updateModuleOption(btn, false);\n        }\n        if (btn.dataset.action === 'moduleaddoption') {\n            this.updateModuleOption(btn, true);\n        }\n        this.setTableData();\n    }\n\n    /**\n     * Inject a new row after this row.\n     * @param {object} btn The button that was clicked.\n     */\n    async addRow(btn) {\n        const modules = State.getValue('modules');\n\n        const moduleid = btn.closest('[data-region=\"module\"]').dataset.id;\n        const module = modules.find(m => m.id == moduleid);\n        const rows = module.rows;\n\n        const row = await this.createRow(rows.length + 1);\n        if (!row) {\n            return;\n        }\n        // Inject the row after the clicked row.\n        rows.push(row);\n        // Compute the id for each cells.\n        State.setValue('modules', modules);\n        this.resetRowSortorder();\n    }\n\n    /**\n     * Recompute the ids for the modules and cells.\n     * @param {Array} modules The modules.\n     * @return {Array} Modules with computed ids (id_answer_0_0, id_answer_0_1, etc.).\n     */\n    async recomputeIds(modules) {\n        // To calculate the answerid index, so we can make up an id related to the row index.\n        // Used in behat tests to find the correct answer input.\n        for (const [moduleIndex, mod] of modules.entries()) {\n            mod.modid = `id_module_${moduleIndex}`; // Used mostly for behat tests.\n            mod.rows.forEach((row, rowIndex) => {\n                row.rowid = `id_row_${moduleIndex}_${rowIndex}`;\n                row.cells = row.cells.map(cell => {\n                    cell.cellid = `id_${cell.column}_${moduleIndex}_${rowIndex}`;\n                    return cell;\n                });\n            });\n        }\n        return modules;\n    }\n    /**\n     * Create a new row.\n     *\n     * @param {int} sortorder The sortorder.\n     * @return {Promise} The promise.\n     */\n    async createRow(sortorder) {\n        let rowid = this.createTempId(this.temprowid++);\n        return new Promise((resolve) => {\n            const row = {};\n            row.id = rowid;\n            row.numoptions = 4;\n            row.sortorder = sortorder;\n            row.type = 1;\n            row.radiochecked = true;\n            const columns = State.getValue('columns');\n            if (columns === undefined) {\n                resolve();\n                return;\n            }\n            // The copy the columns to the row and call them cells.\n            row.cells = columns.map(column => structuredClone(column));\n            // Set the correct types for the cells.\n            row.cells.forEach(cell => {\n                cell.edit = true;\n                cell.value = '';\n                cell[cell.type] = true;\n            });\n            resolve(row);\n        });\n    }\n\n    /**\n     * Delete a row.\n     * @param {Object} btn The button that was clicked.\n     * @return {Promise} The promise.\n     */\n    async deleteRow(btn) {\n        const modules = State.getValue('modules');\n        const rowid = btn.closest('[data-row]').dataset.id;\n        const moduleid = btn.closest('[data-region=\"module\"]').dataset.id;\n        const module = modules.find(m => m.id == moduleid);\n        if (module.rows.length > 1) {\n            const index = module.rows.findIndex(r => r.id == rowid);\n            module.rows.splice(index, 1);\n            this.resetRowSortorder();\n            State.setValue('modules', modules);\n        }\n        return new Promise((resolve) => {\n            resolve(rowid);\n        });\n    }\n\n    /**\n     * Change.\n     * @param {object} input The input that was changed.\n     */\n    change(input) {\n        const row = input.closest('[data-row]');\n        const cell = input.closest('[data-cell]');\n        const value = input.value;\n        const columnid = cell.dataset.columnid;\n        const rowid = row.dataset.id;\n        const modules = State.getValue('modules');\n        modules.forEach(module => {\n            // Find the correct cell in the row.\n            const rowIndex = module.rows.findIndex(r => r.id == rowid);\n            if (rowIndex === -1) {\n                return;\n            }\n            const cellIndexOption = module.rows[rowIndex].cells.findIndex(c => c.columnid == columnid);\n            module.rows[rowIndex].cells[cellIndexOption].value = value;\n            if (module.rows[rowIndex].cells[cellIndexOption].type === 'select') {\n                module.rows[rowIndex].cells[cellIndexOption].options.forEach(option => {\n                    option.selected = option.name === value;\n                });\n            }\n            const cellIndexAnswer = module.rows[rowIndex].cells.findIndex(c => c.column == 'answer');\n            module.rows[rowIndex].cells[cellIndexAnswer].value = value;\n        });\n    }\n\n    /**\n     * Change the module name.\n     * @param {object} element The element that was changed.\n     * @return {void}\n     */\n    changeModule(element) {\n        const moduleElement = element.closest('[data-region=\"module\"]');\n        const moduleid = moduleElement.dataset.id;\n        const name = moduleElement.querySelector('[data-region=\"modulename\"]').value;\n        const type = moduleElement.querySelector('[data-region=\"moduletype\"]').value;\n        const numoptions = moduleElement.querySelector('[data-region=\"numoptions\"]').value;\n        const questionpoints = moduleElement.querySelector('[data-region=\"questionpoints\"]').value;\n        Object.values(this.TYPES).forEach(type => {\n            moduleElement.classList.remove(type);\n        });\n        moduleElement.classList.add(this.TYPES[type]);\n        const modules = State.getValue('modules');\n        modules.forEach(moduleObject => {\n            if (moduleObject.id == moduleid) {\n                moduleObject.modulename = name;\n                moduleObject.type = parseInt(type);\n                moduleObject.class = this.TYPES[type];\n                moduleObject.numoptions = parseInt(numoptions);\n                moduleObject.questionpoints = parseInt(questionpoints);\n                Object.values(this.TYPES).forEach(type => {\n                    moduleObject[type] = false;\n                });\n                moduleObject[this.TYPES[type]] = true;\n            }\n        });\n        this.updateRangeIndicator(moduleElement);\n    }\n\n    /**\n     * Update the module option. Update the value of the numoptions field.\n     * @param {object} btn The button that was clicked.\n     * @param {Boolean} add Add or remove an option.\n     * @return {void}\n     */\n    updateModuleOption(btn, add) {\n        const module = btn.closest('[data-region=\"module\"]');\n        const numoptions = module.querySelector('[data-region=\"numoptions\"]');\n        const value = parseInt(numoptions.value);\n        if (add) {\n            numoptions.value = value + 1;\n        } else {\n            numoptions.value = value - 1;\n        }\n        this.changeModule(numoptions);\n    }\n\n    /**\n     * Update the range indicator.\n     * @param {HTMLElement} moduleElement The module.\n     */\n    async updateRangeIndicator(moduleElement) {\n        const type = moduleElement.querySelector('[data-region=\"moduletype\"]').value;\n        const numoptions = moduleElement.querySelector('[data-region=\"numoptions\"]').value;\n        const indicator = moduleElement.querySelector('[data-region=\"indicator\"]');\n        indicator.textContent = await this.getIndicator(numoptions, type);\n    }\n\n    /**\n     * Get the indicator string\n     * @param {int} numoptions The number of options.\n     * @param {int} type The type.\n     * @return {string} The indicator string.\n     */\n    async getIndicator(numoptions, type) {\n        const stringname = 'indicator:' + this.TYPES[type];\n        const stringtemplate = {\n            'options': numoptions,\n            'lastletter': String.fromCharCode(65 + parseInt(numoptions) - 1),\n        };\n        return await getString(stringname, 'qtype_answersheet', stringtemplate);\n    }\n\n    /**\n     * Delete a module.\n     * @param {object} btn The button that was clicked.\n     * @return {Promise} The promise.\n     * @return {void}\n     */\n    async deleteModule(btn) {\n        const modules = State.getValue('modules');\n        const moduleid = btn.closest('[data-region=\"module\"]').dataset.id;\n        const module = modules.find(m => m.id == moduleid);\n        return new Promise((resolve) => {\n            const index = modules.indexOf(module);\n            modules.splice(index, 1);\n            State.setValue('modules', modules);\n            resolve(moduleid);\n        });\n    }\n\n    /**\n     * Add a new module.\n     * @return {int} The moduleid.\n     */\n    async addModule() {\n        const modules = State.getValue('modules');\n        const numoptions = 4;\n\n        const module = {\n            id: this.createTempId(modules.length + 1),\n            modulesortorder: modules.length + 1,\n            modulename: ' ',\n            type: 1,\n            numoptions: numoptions,\n            questionpoints: 1,\n            indicator: this.getIndicator(numoptions, 1),\n            rows: [await this.createRow(1)],\n        };\n        module[this.TYPES['1']] = true;\n        modules.push(module);\n        await State.setValue('modules', modules);\n    }\n\n    /**\n     * Create a temporary ID for a row.\n     * This is used to identify rows that are not yet saved.\n     * @param {number} numericId\n     * @return {string}\n     */\n    createTempId(numericId) {\n        return `tmp-${numericId}`;\n    }\n\n    /**\n     * Reset the row sortorder values.\n     * @return {void}\n     */\n    resetRowSortorder() {\n        const modules = State.getValue('modules');\n        modules.forEach(module => {\n            module.rows.forEach((row, index) => {\n                row.sortorder = index + 1;\n            });\n        });\n        State.setValue('modules', modules);\n    }\n\n    /**\n     * Navigate to the next or previous row and left or right column.\n     * @param {Event} e The event.\n     * @return {void}\n     */\n    navigate(e) {\n        const currentIndex = e.target.closest('[data-row]').dataset.index;\n        const currentColumn = e.target.closest('[data-cell]').dataset.columnid;\n        const allRows = document.querySelectorAll('[data-row]');\n        for (let i = 0; i < allRows.length; i++) {\n            if (allRows[i].dataset.index == currentIndex) {\n                if (e.key === 'ArrowDown' && i < allRows.length - 1) {\n                    const nextInput = allRows[i + 1].querySelector(`[data-columnid=\"${currentColumn}\"] input`);\n                    if (nextInput) {\n                        nextInput.focus();\n                    }\n                }\n                if (e.key === 'ArrowUp' && i > 0) {\n                    const previousInput = allRows[i - 1].querySelector(`[data-columnid=\"${currentColumn}\"] input`);\n                    if (previousInput) {\n                        previousInput.focus();\n                    }\n                }\n            }\n        }\n        // This part is not working yet, it might not be accessible.\n        if (e.key === 'ArrowRight') {\n            const nextColumn = e.target.closest('[data-cell]').nextElementSibling;\n            if (nextColumn) {\n                nextColumn.focus();\n            }\n        }\n        if (e.key === 'ArrowLeft') {\n            const previousColumn = e.target.closest('[data-cell]').previousElementSibling;\n            if (previousColumn) {\n                previousColumn.focus();\n            }\n        }\n    }\n\n}\n\n/*\n * Initialise\n * @param {HTMLElement} element The element.\n * @param {String} questionid The questionid.\n */\nconst init = (element, questionid) => {\n    new Manager(element, questionid);\n};\n\nexport default {\n    init: init,\n};"],"names":["Manager","constructor","element","questionid","parseInt","addEventListeners","getDatagrid","tempfield","document","querySelector","form","addEventListener","e","btn","target","closest","preventDefault","actions","input","change","modulename","changeModule","moduletype","questionpoints","setTableData","key","navigate","this","getTableData","getTableConfig","response","Repository","getColumns","table","State","setValue","columns","getData","modules","parseModules","error","exception","mod","type","TYPES","indicator","getIndicator","numoptions","rows","forEach","row","selectedValue","cells","cell","column","value","map","find","Object","assign","options","option","clonedOption","name","selected","edit","recomputeIds","getRowObject","checkCellValue","length","substring","cleanModules","cleanedModules","module","rowObject","cleanedRows","cleanedRow","keys","cleanedCell","_cell$options","cleanedModule","sortorder","modulesortorder","push","getValue","JSON","stringify","dataset","action","addRow","deleteRow","addModule","deleteModule","updateModuleOption","moduleid","id","m","createRow","resetRowSortorder","moduleIndex","entries","modid","rowIndex","rowid","cellid","createTempId","temprowid","Promise","resolve","radiochecked","undefined","structuredClone","index","findIndex","r","splice","columnid","cellIndexOption","c","cellIndexAnswer","moduleElement","values","classList","remove","add","moduleObject","class","updateRangeIndicator","textContent","stringname","stringtemplate","String","fromCharCode","indexOf","numericId","currentIndex","currentColumn","allRows","querySelectorAll","i","nextInput","focus","previousInput","nextColumn","nextElementSibling","previousColumn","previousElementSibling","init"],"mappings":"qsBAiCMA,QAmDFC,YAAYC,QAASC,6CA9CT,8EAYA,yEAWJ,oDAME,iCAKF,GACC,iBACA,mBACA,kBAUAD,QAAUA,aACVC,WAAaC,SAASD,iBACtBE,yBACAC,mBACAC,UAAYC,SAASC,cAAc,+BAO5CJ,0BACUK,KAAOF,SAASC,cAAc,uBACpCC,KAAKC,iBAAiB,SAAUC,QACxBC,IAAMD,EAAEE,OAAOC,QAAQ,iBACvBF,MACAD,EAAEI,sBACGC,QAAQJ,SAIrBH,KAAKC,iBAAiB,UAAWC,UACvBM,MAAQN,EAAEE,OAAOC,QAAQ,gBAC3BG,YACKC,OAAOD,aAEVE,WAAaR,EAAEE,OAAOC,QAAQ,8BAChCK,iBACKC,aAAaD,kBAEhBE,WAAaV,EAAEE,OAAOC,QAAQ,8BAChCO,iBACKD,aAAaC,kBAEhBC,eAAiBX,EAAEE,OAAOC,QAAQ,kCACpCQ,qBACKF,aAAaE,qBAEjBC,kBAGTd,KAAKC,iBAAiB,WAAYC,IAChB,cAAVA,EAAEa,KAAiC,YAAVb,EAAEa,WACtBC,SAASd,GACdA,EAAEI,kBAEQ,UAAVJ,EAAEa,KACFb,EAAEI,oBAGVN,KAAKC,iBAAiB,UAAWC,IAC7BA,EAAEI,8CAKAW,KAAKC,qBACLD,KAAKE,8CAQLC,eAAiBC,oBAAWC,WAAW,CAACC,MAAON,KAAKM,cACpDC,eAAMC,SAAS,UAAWL,SAASM,wCAS/BN,eAAiBC,oBAAWM,QAAQ,CAAClC,WAAYwB,KAAKxB,aAEtDmC,cAAgBX,KAAKY,aAAaT,SAASQ,wBAC3CH,SAAS,UAAWG,cACrBd,eACP,MAAOgB,6BACQC,UAAUD,2BASZF,aACV,MAAMI,OAAOJ,QAAS,OACjBK,KAAOhB,KAAKiB,MAAMF,IAAIC,MAC5BD,IAAIC,OAAQ,EACZD,IAAIG,gBAAkBlB,KAAKmB,aAAaJ,IAAIK,WAAYL,IAAIC,MAC5DD,IAAIM,KAAKC,SAASC,UACVC,cAAgB,GACpBD,IAAIE,MAAMH,SAAQI,OACM,WAAhBA,KAAKC,SACLH,cAAgBE,KAAKE,UAG7BL,IAAIE,MAAQF,IAAIE,MAAMI,KAAIH,aAChBC,OAASZ,IAAIN,QAAQqB,MAAKH,QAAUA,OAAOA,SAAWD,KAAKC,eAG/C,YADlBD,KAAOK,OAAOC,OAAO,GAAIN,KAAMC,SACtBX,OAELU,KAAKO,QAAUP,KAAKO,QAAQJ,KAAIK,eACtBC,aAAeJ,OAAOC,OAAO,GAAIE,eACnCC,aAAaC,OAASZ,gBACtBW,aAAaE,UAAW,GAErBF,iBAGfT,KAAKY,MAAO,EACLZ,kBAMnBf,cAAgBX,KAAKuC,aAAa5B,SAOtC6B,qBACW,MACK,IACE,eACO,kBACJ,MACG,cACE,eACD,WAWzBC,eAAef,MACQ,OAAfA,KAAKE,OAGS,SAAdF,KAAKV,MAAmBU,KAAKE,MAAMc,OAAShB,KAAKgB,SACjDhB,KAAKE,MAAQF,KAAKE,MAAMe,UAAU,EAAGjB,KAAKgB,SAUlDE,aAAajC,eACHkC,eAAiB,UACvBlC,QAAQW,SAAQwB,eACNzB,KAAOyB,OAAOzB,KACd0B,UAAY/C,KAAKwC,eACjBQ,YAAc3B,KAAKQ,KAAIN,YACnB0B,WAAa,UACnBlB,OAAOmB,KAAKH,UAAU1B,MAAMC,SAAQxB,MAChCmD,WAAWnD,KAAOyB,IAAIzB,QAG1BmD,WAAWxB,MAAQF,IAAIE,MAAMI,KAAIH,aACvByB,YAAc,eACfV,eAAef,MACpBK,OAAOmB,KAAKH,UAAU1B,KAAKI,OAAOH,SAAQxB,yBACtCqD,YAAYrD,KAAO4B,KAAK5B,KACJ,YAAhB4B,KAAKC,QAAgC,UAAR7B,OAC7BqD,YAAYrD,2BAAO4B,KAAI,wCAAJ0B,cAAiBvB,KAAIK,QAAUA,OAAOE,WAG1De,eAEJF,cAELI,cAAgB,GACtBA,cAAcC,UAAYR,OAAOS,gBACjCF,cAAcjB,KAAOU,OAAOrD,WAC5B4D,cAAcrC,KAAO8B,OAAO9B,KAC5BqC,cAAcjC,WAAa0B,OAAO1B,WAClCiC,cAAchC,KAAO2B,YACrBK,cAAczD,eAAiBkD,OAAOlD,eACtCiD,eAAeW,KAAKH,kBAEjBR,0CAQDlC,QAAUJ,eAAMkD,SAAS,WACzBZ,eAAiB7C,KAAK4C,aAAajC,cACpC/B,UAAUgD,MAAQ8B,KAAKC,UAAUd,gBAO1CvD,QAAQJ,KACuB,WAAvBA,IAAI0E,QAAQC,aACPC,OAAO5E,KAEW,cAAvBA,IAAI0E,QAAQC,aACPE,UAAU7E,KAEQ,cAAvBA,IAAI0E,QAAQC,aACPG,UAAU9E,KAEQ,iBAAvBA,IAAI0E,QAAQC,aACPI,aAAa/E,KAEK,uBAAvBA,IAAI0E,QAAQC,aACPK,mBAAmBhF,KAAK,GAEN,oBAAvBA,IAAI0E,QAAQC,aACPK,mBAAmBhF,KAAK,QAE5BW,4BAOIX,WACHyB,QAAUJ,eAAMkD,SAAS,WAEzBU,SAAWjF,IAAIE,QAAQ,0BAA0BwE,QAAQQ,GAEzD/C,KADSV,QAAQmB,MAAKuC,GAAKA,EAAED,IAAMD,WACrB9C,KAEdE,UAAYvB,KAAKsE,UAAUjD,KAAKqB,OAAS,GAC1CnB,MAILF,KAAKmC,KAAKjC,oBAEJf,SAAS,UAAWG,cACrB4D,wCAQU5D,aAGV,MAAO6D,YAAazD,OAAQJ,QAAQ8D,UACrC1D,IAAI2D,0BAAqBF,aACzBzD,IAAIM,KAAKC,SAAQ,CAACC,IAAKoD,YACnBpD,IAAIqD,uBAAkBJ,wBAAeG,UACrCpD,IAAIE,MAAQF,IAAIE,MAAMI,KAAIH,OACtBA,KAAKmD,oBAAenD,KAAKC,mBAAU6C,wBAAeG,UAC3CjD,kBAIZf,wBAQK2C,eACRsB,MAAQ5E,KAAK8E,aAAa9E,KAAK+E,oBAC5B,IAAIC,SAASC,gBACV1D,IAAM,GACZA,IAAI6C,GAAKQ,MACTrD,IAAIH,WAAa,EACjBG,IAAI+B,UAAYA,UAChB/B,IAAIP,KAAO,EACXO,IAAI2D,cAAe,QACbzE,QAAUF,eAAMkD,SAAS,gBACf0B,IAAZ1E,SAKJc,IAAIE,MAAQhB,QAAQoB,KAAIF,QAAUyD,gBAAgBzD,UAElDJ,IAAIE,MAAMH,SAAQI,OACdA,KAAKY,MAAO,EACZZ,KAAKE,MAAQ,GACbF,KAAKA,KAAKV,OAAQ,KAEtBiE,QAAQ1D,MAXJ0D,6BAoBI/F,WACNyB,QAAUJ,eAAMkD,SAAS,WACzBmB,MAAQ1F,IAAIE,QAAQ,cAAcwE,QAAQQ,GAC1CD,SAAWjF,IAAIE,QAAQ,0BAA0BwE,QAAQQ,GACzDtB,OAASnC,QAAQmB,MAAKuC,GAAKA,EAAED,IAAMD,cACrCrB,OAAOzB,KAAKqB,OAAS,EAAG,OAClB2C,MAAQvC,OAAOzB,KAAKiE,WAAUC,GAAKA,EAAEnB,IAAMQ,QACjD9B,OAAOzB,KAAKmE,OAAOH,MAAO,QACrBd,mCACC/D,SAAS,UAAWG,gBAEvB,IAAIqE,SAASC,UAChBA,QAAQL,UAQhBpF,OAAOD,aACGgC,IAAMhC,MAAMH,QAAQ,cACpBsC,KAAOnC,MAAMH,QAAQ,eACrBwC,MAAQrC,MAAMqC,MACd6D,SAAW/D,KAAKkC,QAAQ6B,SACxBb,MAAQrD,IAAIqC,QAAQQ,GACV7D,eAAMkD,SAAS,WACvBnC,SAAQwB,eAEN6B,SAAW7B,OAAOzB,KAAKiE,WAAUC,GAAKA,EAAEnB,IAAMQ,YAClC,IAAdD,sBAGEe,gBAAkB5C,OAAOzB,KAAKsD,UAAUlD,MAAM6D,WAAUK,GAAKA,EAAEF,UAAYA,WACjF3C,OAAOzB,KAAKsD,UAAUlD,MAAMiE,iBAAiB9D,MAAQA,MACK,WAAtDkB,OAAOzB,KAAKsD,UAAUlD,MAAMiE,iBAAiB1E,MAC7C8B,OAAOzB,KAAKsD,UAAUlD,MAAMiE,iBAAiBzD,QAAQX,SAAQY,SACzDA,OAAOG,SAAWH,OAAOE,OAASR,eAGpCgE,gBAAkB9C,OAAOzB,KAAKsD,UAAUlD,MAAM6D,WAAUK,GAAiB,UAAZA,EAAEhE,SACrEmB,OAAOzB,KAAKsD,UAAUlD,MAAMmE,iBAAiBhE,MAAQA,SAS7DlC,aAAanB,eACHsH,cAAgBtH,QAAQa,QAAQ,0BAChC+E,SAAW0B,cAAcjC,QAAQQ,GACjChC,KAAOyD,cAAc/G,cAAc,8BAA8B8C,MACjEZ,KAAO6E,cAAc/G,cAAc,8BAA8B8C,MACjER,WAAayE,cAAc/G,cAAc,8BAA8B8C,MACvEhC,eAAiBiG,cAAc/G,cAAc,kCAAkC8C,MACrFG,OAAO+D,OAAO9F,KAAKiB,OAAOK,SAAQN,OAC9B6E,cAAcE,UAAUC,OAAOhF,SAEnC6E,cAAcE,UAAUE,IAAIjG,KAAKiB,MAAMD,OACvBT,eAAMkD,SAAS,WACvBnC,SAAQ4E,eACRA,aAAa9B,IAAMD,WACnB+B,aAAazG,WAAa2C,KAC1B8D,aAAalF,KAAOvC,SAASuC,MAC7BkF,aAAaC,MAAQnG,KAAKiB,MAAMD,MAChCkF,aAAa9E,WAAa3C,SAAS2C,YACnC8E,aAAatG,eAAiBnB,SAASmB,gBACvCmC,OAAO+D,OAAO9F,KAAKiB,OAAOK,SAAQN,OAC9BkF,aAAalF,OAAQ,KAEzBkF,aAAalG,KAAKiB,MAAMD,QAAS,WAGpCoF,qBAAqBP,eAS9B3B,mBAAmBhF,IAAK+G,WAEd7E,WADSlC,IAAIE,QAAQ,0BACDN,cAAc,8BAClC8C,MAAQnD,SAAS2C,WAAWQ,OAE9BR,WAAWQ,MADXqE,IACmBrE,MAAQ,EAERA,MAAQ,OAE1BlC,aAAa0B,uCAOKyE,qBACjB7E,KAAO6E,cAAc/G,cAAc,8BAA8B8C,MACjER,WAAayE,cAAc/G,cAAc,8BAA8B8C,MAC3DiE,cAAc/G,cAAc,6BACpCuH,kBAAoBrG,KAAKmB,aAAaC,WAAYJ,yBAS7CI,WAAYJ,YACrBsF,WAAa,aAAetG,KAAKiB,MAAMD,MACvCuF,eAAiB,SACRnF,sBACGoF,OAAOC,aAAa,GAAKhI,SAAS2C,YAAc,iBAErD,mBAAUkF,WAAY,oBAAqBC,mCASzCrH,WACTyB,QAAUJ,eAAMkD,SAAS,WACzBU,SAAWjF,IAAIE,QAAQ,0BAA0BwE,QAAQQ,GACzDtB,OAASnC,QAAQmB,MAAKuC,GAAKA,EAAED,IAAMD,kBAClC,IAAIa,SAASC,gBACVI,MAAQ1E,QAAQ+F,QAAQ5D,QAC9BnC,QAAQ6E,OAAOH,MAAO,kBAChB7E,SAAS,UAAWG,SAC1BsE,QAAQd,qCASNxD,QAAUJ,eAAMkD,SAAS,WAGzBX,OAAS,CACXsB,GAAIpE,KAAK8E,aAAanE,QAAQ+B,OAAS,GACvCa,gBAAiB5C,QAAQ+B,OAAS,EAClCjD,WAAY,IACZuB,KAAM,EACNI,WAPe,EAQfxB,eAAgB,EAChBsB,UAAWlB,KAAKmB,aATD,EAS0B,GACzCE,KAAM,OAAOrB,KAAKsE,UAAU,KAEhCxB,OAAO9C,KAAKiB,MAAM,KAAQ,EAC1BN,QAAQ6C,KAAKV,cACPvC,eAAMC,SAAS,UAAWG,SASpCmE,aAAa6B,+BACKA,WAOlBpC,0BACU5D,QAAUJ,eAAMkD,SAAS,WAC/B9C,QAAQW,SAAQwB,SACZA,OAAOzB,KAAKC,SAAQ,CAACC,IAAK8D,SACtB9D,IAAI+B,UAAY+B,MAAQ,uBAG1B7E,SAAS,UAAWG,SAQ9BZ,SAASd,SACC2H,aAAe3H,EAAEE,OAAOC,QAAQ,cAAcwE,QAAQyB,MACtDwB,cAAgB5H,EAAEE,OAAOC,QAAQ,eAAewE,QAAQ6B,SACxDqB,QAAUjI,SAASkI,iBAAiB,kBACrC,IAAIC,EAAI,EAAGA,EAAIF,QAAQpE,OAAQsE,OAC5BF,QAAQE,GAAGpD,QAAQyB,OAASuB,aAAc,IAC5B,cAAV3H,EAAEa,KAAuBkH,EAAIF,QAAQpE,OAAS,EAAG,OAC3CuE,UAAYH,QAAQE,EAAI,GAAGlI,wCAAiC+H,2BAC9DI,WACAA,UAAUC,WAGJ,YAAVjI,EAAEa,KAAqBkH,EAAI,EAAG,OACxBG,cAAgBL,QAAQE,EAAI,GAAGlI,wCAAiC+H,2BAClEM,eACAA,cAAcD,YAMhB,eAAVjI,EAAEa,IAAsB,OAClBsH,WAAanI,EAAEE,OAAOC,QAAQ,eAAeiI,mBAC/CD,YACAA,WAAWF,WAGL,cAAVjI,EAAEa,IAAqB,OACjBwH,eAAiBrI,EAAEE,OAAOC,QAAQ,eAAemI,uBACnDD,gBACAA,eAAeJ,uBAgBhB,CACXM,KALS,CAACjJ,QAASC,kBACfH,QAAQE,QAASC"}